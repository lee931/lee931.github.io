<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AVR 编程 ATMEGA328P Timer基础应用</title>
    <url>/posts/40514/</url>
    <content><![CDATA[<p>适用于初学者的AVR教程。</p>
<span id="more"></span>

<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>理解定时器的定义，学会使用定时器发生间隔1ms的中断（代码1、2）。通过定时器使LED进行Diming（PWM）。</p>
<hr>
<h2 id="使用到的硬件"><a href="#使用到的硬件" class="headerlink" title="使用到的硬件"></a>使用到的硬件</h2><ol>
<li>Arduino uno</li>
<li>面包板</li>
<li>杜邦线</li>
<li>电阻</li>
<li>LED</li>
</ol>
<hr>
<h2 id="电路图"><a href="#电路图" class="headerlink" title="电路图"></a>电路图</h2><p>Atmega328P的定时器有两种：8bit和16bit。本文使用的是8bit定时器timer0。该定时器有七种模式，最典型的应用是普通模式、CTC模式和快速PWM模式。<br>对于普通模式和CTC模式，示例代码使用的是Pin13上的LED，这意味着不需要任何接线。对于快速PWM模式。示例代码使用的是Pin6的PWM功能（OC0A）。该示例接线很简单，将电阻和LED简单串联即可。也可以使用<a href="https://lee931.github.io/2021/02/16/Atmega328P-GPIO-AVR/">AVR 编程 ATMEGA328P GPIO 基础应用</a>中的三极管开关接法。</p>
<hr>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>1.普通模式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;avr/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BV(X) 1&lt;&lt;X</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timerinit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cli();</span><br><span class="line">  TCCR0A =<span class="number">0</span>;</span><br><span class="line">  TCCR0B = _BV(CS01) | _BV(CS00);</span><br><span class="line">  TCNT0=<span class="number">5</span>;</span><br><span class="line">  TIMSK0 = _BV(TOIE0);</span><br><span class="line">  TIFR0 = _BV(TOV0);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  timerinit();</span><br><span class="line">  DDRB = (<span class="number">1</span> &lt;&lt; PB5);</span><br><span class="line">  sei();</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    PORTB = a &lt;&lt; PB5;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ISR(TIMER0_OVF_vect) &#123;</span><br><span class="line">  TCNT0=<span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= <span class="number">1000</span>)i++;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    a = ~a;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.CTC模式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;avr/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BV(x) 1&lt;&lt;x</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timerinit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cli();</span><br><span class="line">  TCCR0A = _BV(WGM01) | _BV(COM0A1);</span><br><span class="line">  TCCR0B = _BV(CS01) | _BV(CS00);</span><br><span class="line">  OCR0A = <span class="number">249</span>;</span><br><span class="line">  TIMSK0 = _BV(OCIE0A);</span><br><span class="line">  TIFR0 = _BV(OCF0A);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  timerinit();</span><br><span class="line">  DDRB = (<span class="number">1</span> &lt;&lt; PB5);</span><br><span class="line">  sei();</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    PORTB = a &lt;&lt; PB5;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ISR(TIMER0_COMPA_vect) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= <span class="number">1000</span>)i++;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    a = ~a;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.快速PWM模式（LED Diming）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;avr/io.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timerinit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  TCCR0A = (<span class="number">1</span> &lt;&lt; COM0A1) | (<span class="number">0</span> &lt;&lt; COM0A0) | (<span class="number">1</span> &lt;&lt; WGM01) | (<span class="number">1</span> &lt;&lt; WGM00);</span><br><span class="line">  TCCR0B = (<span class="number">0</span> &lt;&lt; WGM02) | (<span class="number">1</span> &lt;&lt; CS01) | (<span class="number">1</span> &lt;&lt; CS00);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  timerinit();</span><br><span class="line">  DDRD = (<span class="number">1</span> &lt;&lt; PD6);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    OCR0A = b;</span><br><span class="line">    b = b + c;</span><br><span class="line">    <span class="keyword">if</span> (b &lt;= <span class="number">0</span> || b &gt;= <span class="number">255</span>) c = -c;</span><br><span class="line">    _delay_ms(<span class="number">30</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Timer和PWM"><a href="#Timer和PWM" class="headerlink" title="Timer和PWM"></a>Timer和PWM</h2><p>假定读者对PWM调波和定时器有一定的了解，因为手头没有示波器可用，无法很具体的讲解，本文对此仅作简单描述。但是作为最基础的电气知识，即使是百度百科也写的很清楚，如果没有相对的知识储备，建议最少阅读一下<a href="https://baike.baidu.com/item/%E8%84%89%E5%86%B2%E5%AE%BD%E5%BA%A6%E8%B0%83%E5%88%B6/10813756?fromtitle=PWM&fromid=3034961">百度百科：脉宽调制</a>。<br>对于定时器的概念：定时器可以看作是一个带有比较逻辑结构的累加器。它的工作原理是不断的给一个数+1，然后将这个数与预设数作比较，当达该数到预设值时溢出并重置。<br>关于PWM，它经常被用于调节方波的占空比。所谓占空比指的是高电平占总带宽的比例，这里占指的是占用，空指的是空置。计算公式为：d=T_h/(T_l+T_h )。以8bit分辨率的PWM方波为例，高低电平分布为0x00-&gt;0xff。假设分布为0xf0：高高高高低低低低，那么它的占空比就是d=4/(4+4)=50%。控制占空比又有什么作用呢？以示例Diming为例，占空比越高LED的亮度就越大。当然，最典型的应用还是在电机上，比如vfc和foc。<br>Atmega328P的定时器有两种：8bit和16bit。二者最明显的区别在于当应用于PWM时，16bit产生的方波分辨率会更高。用上文提到的占空比公式可以计算出来，8bit定时器产生的最小占空比为1/8，而16bit的为1/16，两倍的分辨率。<br>那么是不是分辨率越高越好呢？<br><img src="/image/Arduino/timer/timer.PNG" alt="定时器工作原理" title="定时器工作原理"><br>首先需要弄懂定时器到底是怎么工作的。如上图所示，定时器从某个值（通常为0）不断累加并进行判断是否达到了预设值，如果达到了就溢出重置初始值。具体在硬件上的累加可以理解为这是一个8bit存储单元，给定其初始值并不断累加，当达到预设值时产生溢出标志，并重置该值。<br>那么怎么计时呢？以Atmega328P为例，它的时钟源是由一个16MHZ的晶振提供的，这意味着它一秒可以计数16M次。那么定时器在不分频的情况下每加1一次，过去的时间就是(1/16M)s。对于分频，分频是将时钟源分成n等份。比如最常用的64分频下每秒可以计数250000次。那么假定在64分频下使用8bit分辨率的定时器，每分钟会溢出多少次呢？假设初始值为0，预设值为0xff（即255）。那么该定时器每秒钟溢出的次数为：16MHZ/(64<em>2^8)，大约是98次。由此可以得出时钟带宽公式：f=f_clk/(n</em>2^8 )。<br>现在回到那个问题上：分辨率是不是越高越好呢？根据带宽公式可以得出这样一个结论，当你的分辨率越高时你的时钟带宽就越小。所以根据不同的需求，分辨率不一定是越高越好。那么16bit定时器是不是一定比8bit的好呢？是的，因为可以通过改变预设值将16bit定时器应用为8bit定时器。</p>
<hr>
<h2 id="如何实现1ms精准定时及如何产生PWM方波"><a href="#如何实现1ms精准定时及如何产生PWM方波" class="headerlink" title="如何实现1ms精准定时及如何产生PWM方波"></a>如何实现1ms精准定时及如何产生PWM方波</h2><p>本文使用的是8bit定时器timer0。该定时器有七种模式，最典型的应用是普通模式、CTC模式和快速PWM模式。<br>普通模式和CTC模式可以用于精准定时。在上文中提到过，时钟分辨率是通过初始值和预设值来确定的，二者相减就是时钟分辨率。在Atmega328P上有如下的定义：<br>|   名称   |      定义    |<br>|  :—-:  |     :—-:   |<br>| BOTTOM  | 底部值时0x00|<br>|MAX           | 峰值0xff    |<br>|TOP       | 预设值       |<br>简单来说，对于CTC模式，底部值是BOTTOM，溢出值是TOP（即寄存器OCRnx内的值）。对于普通模式，底部值是寄存器TCNTn内储存的值，溢出值是MAX。二者在实际使用效果上没有区别。<br>快速PWM模式用于生成单斜率方波，对应的还有PWM相位矫正模式是双斜率的。二者的区别在于快速PWM模式在MAX/TOP溢出，而相位矫正模式则从MAX/TOP再减到BOTTOM。那么定时器是如何生成PWM方波、又是如何调节占空比的呢？<br><img src="/image/Arduino/timer/fastPWM.PNG" alt="快速PWM时序图" title="快速PWM时序图"><br>上图是快速PWM模式的时序图，每个周期被平均分为256份（8bit分辨率），OCnx为在该周期内高电平的份数。比如输出一个50%占空比的方波信号，OCnx值为127。该值储存在寄存器OCRnx内。n指的是Timer0/1/2，x指的是通道A/B。<br>关于PWM双通道，Atmega328P的定时器在使用到对比模块的模式下被设计为双通道模式，包括并不限于快速PWM和CTC模式。每个通道都有一个预设值寄存器OCRnA/B。在CTC模式下，可以通过分别赋予OCRnA/B不同的值来实现双通道独立计时。在快速PWM模式下则可以通过双通道设计，产生两个占空比不一样的方波。<br>那么该如何实现1ms精准定时、如何产生PWM方波呢？<br><img src="/image/Arduino/timer/MOD.PNG" alt="模式配置表" title="模式配置表"><br><img src="/image/Arduino/timer/FP.PNG" alt="分频配置表" title="分频配置表"><br><img src="/image/Arduino/timer/TCCR0A.PNG" alt="寄存器TCCR0A" title="寄存器TCCR0A"><br><img src="/image/Arduino/timer/TCCR0B.PNG" alt="寄存器TCCR0B" title="寄存器TCCR0B"><br><img src="/image/Arduino/timer/TIMSK.PNG" alt="寄存器TIMSK0" title="寄存器TIMSK0"><br><img src="/image/Arduino/timer/TIFR.PNG" alt="寄存器TIFR0" title="寄存器TIFR0"><br><img src="/image/Arduino/timer/FZ.PNG" alt="比较值寄存器" title="比较值寄存器"><br>上图是定时器0的各个模式的寄存器配置表、分频配置表及相关寄存器。使用定时器，首先要配置它的模式。然后再配置它的分频，接着再配置通道数和它们的预设值（比如OCRnx或TCNTn）。最后再根据需要来决定是否要配置中断。<br>以CTC模式为例，从上表中可以看到，CTC模式为模式3，其配置方法为将寄存器TCCR0A 上的WGM01位置1。使用64分频，即将寄存器TCCR0B上的CS01和CS00位置1。然后选用单通道、通道A，即将寄存器TCCR0A上的COM0A1位置1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TCCR0A = _BV(WGM01) | _BV(COM0A1);</span><br><span class="line">TCCR0B = _BV(CS01) | _BV(CS00);</span><br></pre></td></tr></table></figure>
<p><img src="/image/Arduino/timer/CTC.PNG" alt="CTC选通" title=" CTC选通"><br>关于选通,以通道A为例。上图可以看到有四个选项。第一项是禁用该通道。第二项是更改Pin-OCnA的电平状态，一般在PWM模式下使用。第三项是常用的清零，即当溢出时，计数器值变为0x00。第四项是置位，此时类似于普通模式下的TCNTn，一般不用。<br>要产生1ms的标准时间，已知在64分频下一秒可以累加250000次，那么只要让定时器每累加250次溢出一次就可以得到精确的时间。需要注意的是溢出到0x00也记作一次累加，所以预设值OCR0A为249，即：<code>OCR0A = 249</code>。<br>假设需要中断，那么将掩码寄存器和标志寄存器的A通道置1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIMSK0 = _BV(OCIE0A);</span><br><span class="line">TIFR0 = _BV(OCF0A);</span><br></pre></td></tr></table></figure>
<p>普通模式与CTC模式配置方法类似，此处不再详述。其与CTC模式的区别在于普通模式没有双通道。且其计数方式为从预赋值TCNTn到MAX。所以不需要配置OCR0A，而需要配置TCNT0。同样以64分频的1ms定时为例，TCNT0为5，即：<code>TCNT0=5</code>。<br>注意：这里不需要减1，因为累加范围为5-255，刚好250次。<br>关于AVR的中断用法和中断向量表，请见<a href="https://lee931.github.io/2021/03/05/AVR-%E7%BC%96%E7%A8%8B-ATMEGA328P-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/">AVR 编程 ATMEGA328P 中断基础</a>。<br>PWM相对较难，其难点主要在于双通道选通。从模式配置表中可以看到有两个快速PWM模式，其区别在于TOP值和溢出值上。模式3的溢出值是MAX，即0xff。这意味着它的带宽是固定的8bit。模式7的溢出值是OCRA，这意味着它的带宽是不定的，且在该模式下由于没有更多的寄存器来调控占空比，它的占空比恒定位50%。<br><img src="/image/Arduino/timer/fastPWMCOM.PNG" alt="快速PWM选通" title="快速PWM选通"><br>上图是PWM模式下通道A选通的选项。第一项还是禁用。第二项应用在模式7上，生成一个占空比为50%的方波信号，其带宽取决于OCRA。原理是第一个波段高电平，下一个波段反转电平。第三项、第四项用在模式3上，取决于你的方波信号是否需要反转（比如电机倒转）。<br>示例代码旨在实现LED的Diming，所以需要通过改变方波的占空比来达到更改LED亮度的目的。上文已经解释了模式3和模式7的区别，对于LED调光需要使用模式3，因为改变的是占空比而不是带宽。所以寄存器TCCR0A的WGM01和WGM00需要置1。关于选通，选择通道A禁用通道B，且不需要反转，即寄存器WGM01的COM0A1置1。分频与CTC一致，选择64分频。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TCCR0A = (<span class="number">1</span> &lt;&lt; COM0A1) | (<span class="number">1</span> &lt;&lt; WGM01) | (<span class="number">1</span> &lt;&lt; WGM00);</span><br><span class="line">TCCR0B = (<span class="number">1</span> &lt;&lt; CS01) | (<span class="number">1</span> &lt;&lt; CS00);</span><br></pre></td></tr></table></figure>
<p><img src="/image/Arduino/interrupt/yjt.PNG" alt="Arduino引脚图" title="Arduino引脚图"><br>上图是Arduino的引脚图，已知开启了Timer0的A通道作为PWM输出引脚，所以要在引脚图上找到OC0A引脚，即PD6。直接将LED和电阻串接到该引脚，LED的Diming电路就接好了。<br>对于Diming的算法，示例提供了一个很简单的动态占空比的算法。原理是亮度变量b（brightness）和控制变量c（control）相加得到即时亮度，当亮度和超过255或者低于0时，反转c的正负号。这样亮度就会在0-&gt;255之间变化。<br>注意：PWM模式是没有中断的，但是可以通过定时器的普通模式和CTC模式来模拟产生PWM方波。</p>
<hr>
<h2 id="关于本文"><a href="#关于本文" class="headerlink" title="关于本文"></a>关于本文</h2><p>Arduino定时器功能挺难找到中文的讲解的，大部分写的都是一知半解（比如很难找到关于Toggle这个单词的解释）。有一篇德语的文章写的非常棒，作者还用示波器对比了定时器各个模式下的波形。如果想完整的了解Arduino的PWM功能，可以区看看：<a href="https://wolles-elektronikkiste.de/timer-und-pwm-teil-1">Timer und PWM – Teil 1 (8 Bit Timer0/2)</a>。<br>本文还有许多需要完善的地方，因为关于定时器的东西比较多，讲解起来比较复杂。后续可能会在有时间的时候进行修补。再次推荐上面的链接。</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.Atmega328P数据手册<br><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf">链接</a><br>2.Arduino引脚图<br><a href="https://content.arduino.cc/assets/Pinout-UNOrev3_latest.pdf">链接</a></p>
]]></content>
      <tags>
        <tag>avr</tag>
      </tags>
  </entry>
  <entry>
    <title>AVR 编程 ATMEGA328P GPIO 基础应用</title>
    <url>/posts/aa5/</url>
    <content><![CDATA[<p>适用于刚从Arduino语言转到AVR C语言编程的人。</p>
<span id="more"></span>

<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>理解AVR架构下GPIO的使用，即输入和输出。理解寄存器赋值和Arduino语言赋值的区别。实现用开关控制LED的点亮和熄灭。</p>
<hr>
<h2 id="使用到的硬件"><a href="#使用到的硬件" class="headerlink" title="使用到的硬件"></a>使用到的硬件</h2><ol>
<li>Arduino uno</li>
<li>面包板</li>
<li>杜邦线</li>
<li>电阻</li>
<li>开关</li>
<li>LED</li>
<li>三极管</li>
</ol>
<hr>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;avr/io.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  DDRD = <span class="number">1</span> &lt;&lt; DDD3;</span><br><span class="line">  DDRC = <span class="number">0</span> &lt;&lt; DDC0;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( PINC &amp; (<span class="number">1</span> &lt;&lt; PINC0) ) &#123;</span><br><span class="line">      PORTD = <span class="number">1</span> &lt;&lt; PD3;<span class="comment">// pin is high</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      PORTD = <span class="number">0</span> &lt;&lt; PD3;  <span class="comment">// pin is low</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="电路图"><a href="#电路图" class="headerlink" title="电路图"></a>电路图</h2><p><img src="/image/Arduino/gpio/dl.PNG" alt="开关灯电路电路图" title="开关灯电路电路图"><br>需要注意的是，这里关于LED部分使用了一个三极管开关电路。如果你没有三极管，可以直接将Pin和LED及电阻连接。Arduino有足够的电流供给，该电路适用于弱电流GPIO的开发板，比如Jetson Nano。</p>
<hr>
<h2 id="嵌入式的“Hello-World”，点亮一盏LED"><a href="#嵌入式的“Hello-World”，点亮一盏LED" class="headerlink" title="嵌入式的“Hello World”，点亮一盏LED"></a>嵌入式的“Hello World”，点亮一盏LED</h2><p>在Arduino语言中，只需要给某个Pin赋值就可以点亮一盏LED。用C语言编程与Arduino语言编程过程一致。首先看一下如何用Arduino语言点亮一盏灯：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> led 13</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  pinMode(led, OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  digitalWrite(led, HIGH);   </span><br><span class="line">  delay(<span class="number">1000</span>);      </span><br><span class="line">  digitalWrite(led, LOW);   </span><br><span class="line">  delay(<span class="number">1000</span>);                   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序可以在Arduino IDE的示例Blink中查看，其功能是小灯按两秒一个周期的频率闪烁。那么点亮一盏LED需要做什么？首先在“setup()”里初始化Pin的方向（输入or输出），然后给该Pin赋值0（熄灭）/1（点亮）。<br>那么同样的，使用C语言编程，也要完成这两步。Atmega328P的每个Pin有三个寄存器，可以通过配置这些寄存器来实现一些GPIO的功能。这里需要用到两个寄存器：DDxn和PORTxn。除了这两个寄存器，每个Pin还有一个Pinxn寄存器。关于这三个寄存器的详细描述，请参考文献：数据手册的P59。<br>如果你学过51单片机，那么应该对寄存器很了解了。在Atmega上的使用方法上没有区别。如果你并不了解寄存器，关于寄存器，它可以理解为一个开关，一般它的每一位有两个值0/1。假设我们的动作器是个灯，那么我可以通过操控这个开关来改变动作器的状态（点亮or熄灭）。以方向寄存器DDxn为例，这里的“x”代表着你所使用的Pin的Port位置。“n”代表着Pin在该Port上的位置。你可以很容易的在网络上找到Arduino的引脚图，比如下图是在Arduino官网截的：<br><img src="/image/Arduino/Pindiagram.PNG" alt="Arduino Pin-Diagram" title="Arduino Pin-Diagram"><br>回到点亮一盏LED上，首先需要配置Pin的方向，需要用到寄存器DDxn。当该寄存器为0时，Pin被配置成输入，1则是输出。从上图中可以很容易的找到你所使用的Pin的寄存器位置。以D3为例，它的寄存器位置为PD3。将该Pin配置为输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DDRD = <span class="number">1</span> &lt;&lt; DDD3;</span><br></pre></td></tr></table></figure>
<p>DDRD（可以理解为Digital Direction D）是整个PortD的方向寄存器，DDD3是Pin-D3的方向寄存器。通常来说我们配置一个Pin的方向，并不希望改变其它Pin的方向。所以需要通过移位运算来给DDD3赋值。当然你也可以用字节操作的方式来给DDD3赋值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DDRD |= <span class="number">0x04</span>;</span><br></pre></td></tr></table></figure>
<p>现在进行第二步，对Pin的高-低电平状态赋值。将该Pin配置为高电平：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PORTD = <span class="number">1</span> &lt;&lt; PD3;</span><br></pre></td></tr></table></figure>
<p>最后，来实现一下与示例Blink一样的功能：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;avr/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;util/delay.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DDRD = <span class="number">1</span> &lt;&lt; DDD3;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      PORTD = <span class="number">1</span> &lt;&lt; PD3;<span class="comment">// pin is high</span></span><br><span class="line">      _delay_ms(<span class="number">1000</span>);</span><br><span class="line">      PORTD = <span class="number">0</span> &lt;&lt; PD3;  <span class="comment">// pin is low</span></span><br><span class="line">      _delay_ms(<span class="number">1000</span>);*/      </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：在库&lt;util/delay.h&gt;中，delay函数为“_delay_ms(num); ” “ _delay_ns(num); ”两种。使用Arduino语言中的“delay（num）”无法实现延时功能。</p>
<hr>
<h2 id="使用开关控制LED"><a href="#使用开关控制LED" class="headerlink" title="使用开关控制LED"></a>使用开关控制LED</h2><p>对于配置一个Pin的功能，在手册P60可以找到下图这张表格：<br><img src="/image/Arduino/gpio/ddrx.PNG" alt="Pin寄存器配置表" title="Pin寄存器配置表"><br>不同于点亮一盏LED，对于按键，需要将方向配置为输入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DDRC = <span class="number">0</span> &lt;&lt; DDC0;</span><br></pre></td></tr></table></figure>
<p>读取按键的状态需要用到寄存器“PINx”。该寄存器会返回所选Port的电平状态，高为1，低为0。我们需要对按键的状态进行判断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( PINC &amp; (<span class="number">1</span> &lt;&lt; PINC0) ) &#123;&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，PINx寄存器是整个PortC的Pin-Status寄存器。需要通过移位指令和逻辑运算来提取所选Pin的电平状态。</p>
<hr>
<h2 id="对移位指令的简化"><a href="#对移位指令的简化" class="headerlink" title="对移位指令的简化"></a>对移位指令的简化</h2><p>在AVR编程中，位移指令和逻辑运算会经常用到，不熟悉的话可以在程序顶端添加下列程序对位移指令和逻辑运算进行封装：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT(b) (1&lt;&lt;b)			<span class="comment">//提取第b位</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET(x,y) (x |= y)		<span class="comment">//置1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLEAR(x,y) (x &amp;=~ y)	<span class="comment">//清零</span></span></span><br></pre></td></tr></table></figure>
<p>然后通过下列方法来配置Pin：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1 BIT(3)</span></span><br><span class="line">SET(DDRD,LED1);		<span class="comment">//输出</span></span><br><span class="line">CLEAR(PORTD,LED1);		<span class="comment">//低电平</span></span><br><span class="line">SET(PORTD,LED1);		<span class="comment">//高电平</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.Atmega328P数据手册<br><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf">链接</a><br>2.Arduino引脚图<br><a href="https://content.arduino.cc/assets/Pinout-UNOrev3_latest.pdf">链接</a></p>
]]></content>
      <tags>
        <tag>avr</tag>
      </tags>
  </entry>
  <entry>
    <title>AVR 编程 ATMEGA328P 中断基础应用</title>
    <url>/posts/cb20/</url>
    <content><![CDATA[<p>适用于初学者的AVR教程。</p>
<span id="more"></span>

<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>理解中断的定义，学会封装函数。通过中断使按键可以控制LED的状态。</p>
<hr>
<h2 id="使用到的硬件"><a href="#使用到的硬件" class="headerlink" title="使用到的硬件"></a>使用到的硬件</h2><ol>
<li>Arduino uno</li>
<li>面包板</li>
<li>杜邦线</li>
<li>电阻</li>
<li>开关</li>
<li>LED</li>
<li>三极管</li>
</ol>
<hr>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;avr/io.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> a = <span class="number">0b01</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptinit</span><span class="params">()</span></span>&#123;</span><br><span class="line">  PCICR=<span class="number">1</span>&lt;&lt;PCIE1;</span><br><span class="line">  PCIFR=<span class="number">1</span>&lt;&lt;PCIF1;</span><br><span class="line">  PCMSK1=(<span class="number">1</span>&lt;&lt;PCINT9);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  DDRB = <span class="number">1</span> &lt;&lt; DDB5;</span><br><span class="line">  PORTB = <span class="number">1</span> &lt;&lt; PB5;</span><br><span class="line">  DDRC = <span class="number">0</span> &lt;&lt; DDC1;</span><br><span class="line">  interruptinit();</span><br><span class="line">  sei();</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    PORTB = a &lt;&lt; PB5;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ISR(PCINT1_vect)&#123;</span><br><span class="line">    <span class="keyword">if</span> (~PINC &amp; (<span class="number">1</span> &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">      a=~a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="电路图"><a href="#电路图" class="headerlink" title="电路图"></a>电路图</h2><p><img src="/image/Arduino/gpio/dl.PNG" alt="开关灯电路电路图" title="开关灯电路电路图"><br>需要注意的是，这里关于LED部分使用了一个三极管开关电路。如果你没有三极管，可以直接将Pin和LED及电阻连接。Arduino有足够的电流供给，该电路适用于弱电流GPIO的开发板，比如Jetson Nano。</p>
<hr>
<h2 id="中断和中断向量"><a href="#中断和中断向量" class="headerlink" title="中断和中断向量"></a>中断和中断向量</h2><p><img src="/image/Arduino/interrupt/zhongduan.PNG" alt="中断流程图" title="中断流程图"><br>如上图所示中断的流程大概分为以下几步：</p>
<ol>
<li>达到一定条件触发中断</li>
<li>根据被触发的中断编号，找到对应的中断向量，再由中断向量指向对应的中断程序</li>
<li>执行中断程序，结束后返回中断点<br>中断向量可能听起来相对陌生，对于它，可以简单的理解为一个指针。该指针指向中断程序的地址。整个中断的过程可以看作是双重指针的应用。首先当中断被触发后，cup记录当前地址，并将下一步运行的地址被指向中断向量表。然后经过查表，找到所使用的中断向量。再由该向量指向需要被执行的中断程序。执行结束后通过触发中断时记录的地址返回中断点。<br>在一些老式的单片机上，比如瑞萨的M16C。当使用中断时（定时器也是中断的一种），需要手动改写中断向量表来释放中断资源。而Arduino IDE将这一步操作自动执行了，通常来说并不需要更改向量表。如果需要修改中断向量表，请参考数据手册P52。由于这部分内容，新手用不到，老鸟看得懂，在此不做描述。</li>
</ol>
<hr>
<h2 id="Atmega328P上的硬件中断"><a href="#Atmega328P上的硬件中断" class="headerlink" title="Atmega328P上的硬件中断"></a>Atmega328P上的硬件中断</h2><p><img src="/image/Arduino/xlb.PNG" alt="中断向量表" title="中断向量表"><br><img src="/image/Arduino/xiangliangbiao.jpg" alt="中断向量表"><br>在Atmega328上有两个正常的硬件中断，从中断向量表中可以看到分别是INT0和INT1。这两个中断对应的引脚为PD2和PD3。除了这两个中断外，其余的硬件中断为“Pin-Change Interrupt”,简记为PCINT。<br>那么这两种中断有什么区别呢？通常情况下，每个中断都有自己的中断向量，用来寻址。但是Atmega328p的所有GPIO都可以用作中断引脚，如果每个Pin都有一个自己的中断向量，那么向量表就会变得特别冗长。因此PCINT被设计了出来。不同于一般的硬件中断，PCINT分为三组。每组对应8个Pin，通过寄存器PCICR、PCIFR和PCMSKn（此处以PCMSK1为例）来配置：<br><img src="/image/Arduino/interrupt/pcicr.PNG" alt="PCICR" title="PCICR"><br><img src="/image/Arduino/interrupt/pcifr.PNG" alt="PCIFR" title="PCIFR"><br><img src="/image/Arduino/interrupt/pcmsk1.PNG" alt="PCMSK1" title="PCMSK1"><br>这三个寄存器很容易记忆，PC代表着Pin-Change。ICR指的是interrupt control register，IFR指的是interrupt flage register，MSK指的是mask（掩码）。PCICR和PCIFR用来使能你所使用的PCINT0/1/2。PCMSK用来选择具体的引脚位置。示例程序使用PC1作为按键接入口，其中断部分的初始化为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PCICR=<span class="number">1</span>&lt;&lt;PCIE1;</span><br><span class="line">PCIFR=<span class="number">1</span>&lt;&lt;PCIF1;</span><br><span class="line">PCMSK1=(<span class="number">1</span>&lt;&lt;PCINT9);</span><br></pre></td></tr></table></figure>
<p>在完成初始化之后，即可以开始使用该PCINT了。首先使用<code>sei();</code>来打开中断。然后使用下面的结构编写中断程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ISR(你的中断向量)&#123;</span><br><span class="line">    <span class="comment">//你的中断程序</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，由于PCINT0/1/2的每个中断向量都对应着多个Pin，因此还需要在中断程序中对于具体Pin的位置进行判断。比如，示例中更改参数a的状态：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (~PINC &amp; (<span class="number">1</span> &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">  a=~a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再说回普通的硬件中断，INT0和INT1。他们初始化使用的寄存器为EICRA、EIMSK和EIFR。其初始化方法与PCINT类似，详细描述可以参考手册P54。与PCINT的区别在于由于具有具有单独的中断向量，INT0和INT1不需要通过额外的判断来确定具体的Pin的位置。且通过配置寄存器EICRA，可以选择4种中断被触发的方式：高电平触发，低电平触发，上升沿触发和下降沿触发。而在PCINT中，触发方式需要程序员在判断Pin的位置时自行编写。示例程序中的触发方式为低电平触发。<br>Tips：<br>对于函数<code>sei();</code>，有一个功能相反的函数<code>cli();</code>。该函数的功能是禁用所有中断。当你有一段程序不想被仍和中断打扰时，可以在该段程序前添加函数<code>cli();</code>、末尾添加函数<code>sei();</code>来在该段程序中屏蔽所有中断功能。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.Atmega328P数据手册<br><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf">链接</a><br>2.Arduino引脚图<br><a href="https://content.arduino.cc/assets/Pinout-UNOrev3_latest.pdf">链接</a></p>
]]></content>
      <tags>
        <tag>avr</tag>
      </tags>
  </entry>
</search>
